#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Nov  8 10:39:20 2022
This script is used to generate a summary table of m6A sites from tagged SAM file
@author: heavens
"""
import os
import re
import sys
import pysam
import argparse
import numpy as np
import pandas as pd
from tqdm import tqdm
FLAGS = {"5mC":"C+m","5hmC":"C+h","5fC":"C+f","5caC":"C+c",
         "5hmU":"T+g","5fU":"T+e","5caU":"T+b",
         "6mA":"A+a",
         "8oxoG":"G+o",
         "Xao":"N+n"}
complementary_base = {'A':'T','T':'A','C':'G','G':'C','N':'N'}
motif_reg = {"A":"A","C":"C","G":"G","T":"T","U":"U","R":"[AG]","Y":"[CT]","M":"[AC]","K":"[GT]","S":"[GC]","W":"[AT]","B":"[CGT]","D":"[AGT]","H":"[ACT]","V":"[ACG]","N":"[ACGT]"}
def get_reg(motif):
    reg = ""
    for i in motif:
        reg += motif_reg[i]
    return reg
class MethParser(object):
    def __init__(self,modified):
        self.modified = modified
        self.flag = FLAGS[modified]

    def parse_MMflag(self,aln):
        split_aln = aln.strip().split('\t')
        MMs = {}
        MLs = {}
        for field in split_aln:
            if field.startswith('MM:Z:'):
                MM_tags = field[5:].strip(';').split(';')
                for MM_tag in MM_tags:
                    codes,positions = self.parse_MMtag(MM_tag)
                    for code,position in zip(codes,positions):
                        MMs[code] = np.asarray(positions,dtype = int)
            if field.startswith("ML:B:C"):
                split_ML = field[7:].split(',')
                if len(split_ML) != sum(len(x) for x in MMs.values()):
                    return None,None
                for key,val in MMs.items():
                    c = len(val)
                    MLs[key] = np.asarray([int(x) for x in split_ML[:c]],dtype = np.uint8)
                    del split_ML[:c]
        return MMs,MLs

    def parse_MMtag(self,MM_tag):
        #Parse single MM tag for each modification
        MM_tag_split = MM_tag.split(',')
        title = MM_tag_split[0].strip('.').strip('?')
        unmo_base,mo_base = title.split('+')
        if len(mo_base)>1:
            raise ValueError("Multi modification format is currently not supported.")
        mo_codes = [title]
        if MM_tag_split[1] == '':
            mo_pos = []
        else:
            mo_pos = [int(x) for x in MM_tag_split[1:]]
            
        return mo_codes,mo_pos

    def expand_compact_mm(self,mm,ml):
        """
        Expand the compact MM probability into a long one.

        Parameters
        ----------
        mm : array
            The compact methylation jump array.
        ml : array
            The compact methylation likelihood array.

        Returns
        -------
        expand_ml : array
            The expanded methylation likelihood array.

        """
        expand_ml = []
        for i,jump in enumerate(mm):
            expand_ml+= [0]*jump
            expand_ml+= [ml[i]]
        return np.asarray(expand_ml,dtype = np.uint8)

    def meth_pileup(self,
                    sam:pysam.libcalignmentfile.AlignmentFile,
                    ref:pysam.libcfaidx.FastaFile,
                    region:str,
                    start:int,
                    end:int,
                    motif = None,
                    span:int = 5,
                    threshold:int = 30):
        """
        Pileup the reads methylation state.

        Parameters
        ----------
        sam : pysam.libcalignmentfile.AlignmentFile
            AlignmentFile generated by pysam.
        ref : pysam.libcfaidx.FastaFile
            Reference index generated by pysam.
        region : str
            The reference region, e.g. chr1.
        start : int
            The start position of the reference to pileup.
        end : int
            The end position of the reference to pileup.
        motif : str, optional
            Only sequence with this motif will be reported. The default is None.
        span : int, optional
            The span of each reference base to record in the pileup. The default is 5.
        threshold : int, optional
            The threshold to call methylation, range from 0 to 255. 
            The default is 125. It's a integer coded probability, [0,255]->[0,1]

        Returns
        -------
        None.

        """
        if type(motif) is str:
            motif = re.compile(get_reg(motif))
        b = self.flag.split('+')[0]
        ref_len = ref.get_reference_length(region)
        reads = sam.fetch(region,start,end)
        refpos,refbase,seq,direction,refseq,ids,likelihood = [],[],[],[],[],[],[]
        mms = np.zeros(0,dtype = np.uint8)
        errors = {"Passed":0,"Inconsistent_ML":0,"Corrupted_MM":0}
        with tqdm() as t:
            for read in reads:
                id = read.tostring().split('\t')[0]
                mm,ml = self.parse_MMflag(read.tostring())
                if mm is None:
                    errors['Corrupted_MM']+=1
                    continue
                mm,ml = mm[self.flag],ml[self.flag]
                if sum(mm>0):
                    ml = self.expand_compact_mm(mm,ml)
                pos_pair = read.get_aligned_pairs(with_seq = True) #[(readpos,refpos,ref_base)]
                refpos += [x[1] for x in pos_pair]
                refbase += [x[2].upper() if x[2] is not None else None for x in pos_pair]
                refseq += [ref.fetch(region,max(x[1]-span,0),min(x[1]+span+1,ref_len)).upper() if x[1] is not None else None for x in pos_pair]
                curr_seq = [read.seq[x[0]].capitalize() if x[0] is not None else '*' for x in pos_pair]
                seq += curr_seq
                ids += [id]*len(curr_seq)
                curr_seq = np.asarray(curr_seq)
                curr_mm = np.zeros_like(curr_seq,dtype = np.uint8)
                if read.is_reverse:
                    curr_b = complementary_base[b]
                    ml = ml[::-1]
                    direction += ['-']*len(curr_seq)
                else:
                    curr_b = b
                    direction += ['+']*len(curr_seq)
                update_mask = curr_seq == curr_b
                if sum(update_mask) != len(ml):
                    errors['Inconsistent_ML']+=1
                    continue
                    #print("Warning, the number of base and ML tag length is not consistent, this will raise an error in the future.")
                if sum(update_mask) > len(ml):
                    if read.is_reverse:    
                        curr_mm[update_mask][-len(ml):] = ml
                    else:
                        curr_mm[update_mask][:len(ml)] = ml
                elif sum(update_mask) < len(ml):
                    if read.is_reverse:    
                        curr_mm[update_mask] = ml[:sum(update_mask)]
                    else:
                        curr_mm[update_mask] = ml[:sum(update_mask)]
                else:
                    errors["Passed"]+=1
                    curr_mm[update_mask] = ml
                mms = np.concatenate((mms,curr_mm),axis = 0)
                t.postfix = "Region {REGION} Read_id: {ID}, Passed:{Passed}, ML and sequence have different length:{Inconsistent_ML},Corrupted MM tag:{Corrupted_MM}".format(REGION=region,ID=id,**errors)
                t.update()
        refpos = [x if x is not None else -1 for x in refpos]
        refpos = np.asarray(refpos,dtype = np.int32)
        refbase = np.asarray(refbase)
        refseq = np.asarray(refseq)
        ids = np.asarray(ids)
        direction = np.asarray(direction)
        seq = np.asarray(seq)
        if len(refpos) == 0:
            return {"refpos":[],"refbase":[],"refseq":[],"qbase":[],"read_id":[],"ml":[],"direction":[],'refseq':[]}
        mask = (refpos>=start)&(refpos<end)
        if motif is not None:
            motif_mask = np.asarray([(re.match(motif,x) is not None) if x else False for x in refseq])
            mask = mask&motif_mask
        return {"refpos":refpos[mask],'refbase':refbase[mask],'qbase':seq[mask],'read_id':ids[mask],'ml':mms[mask],'direction':direction[mask],'refseq':refseq[mask]}

def main(args):
    sam_f = args.bam
    ref_f = args.ref
    out = args.out
    motif = args.motif
    # Read in m6A sites from SAM file
    parser = MethParser("6mA")
    if motif is not None:
        motif = motif.upper()
        motif_re = re.compile(get_reg(motif))
    samfile = pysam.AlignmentFile(sam_f, "rb")
    reffile = pysam.FastaFile(ref_f)
    down_stream,up_stream = 5,5
    result = []
    for region in samfile.references:
        pileup = parser.meth_pileup(samfile,reffile,region,0,samfile.get_reference_length(region),motif = motif)
        pileup = pd.DataFrame(pileup)
        pileup.sort_values(by=['refpos'],inplace=True,ignore_index=True)
        pileup['contig'] = region
        result.append(pileup)
    datasets = pd.concat(result)
    datasets.to_csv(os.path.join(out,"{MOTIF}_m6A_read_summary{SUFFIX}.csv".format(MOTIF=motif,SUFFIX="" if args.suffix is None else "_"+args.suffix)),index=False)

# Read in putative m6A sites from anti-body capture dataset
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Parse m6A sites from SAM file')
    parser.add_argument('-b','--bam',help='BAM file contain methylation annotation.',required=True)
    parser.add_argument('-r','--ref',help='Reference file',required=True)
    parser.add_argument('-o','--out',help='Output directory',required=True)
    parser.add_argument('-m','--motif',help='Motif to filter',default=None)
    parser.add_argument('--suffix',help='Suffix for output file',default=None)
    args = parser.parse_args(sys.argv[1:])
    os.makedirs(args.out,exist_ok=True)
    main(args)
    

    # ref_f = "/home/heavens/bridge_scratch/ime4_Yearst/Yearst/Yeast_sk1.fasta"
    # motif = "DRACH"
    # sam_f = "/home/heavens/bridge_scratch/ime4_Yearst/Yearst/ko_raw_fast5/xron_crosslink/assess/aln.tagged.sorted.bam"
    # out_f = "/home/heavens/bridge_scratch/Xron_Project/"

